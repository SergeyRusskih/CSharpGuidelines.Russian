---
title: Различные рекомендации по проектированию
permalink: /misc-design-guidelines/
classes: wide
search: true
sidebar:
  nav: "sidebar"
---

### <a name="av1200"></a> Бросайте исключение вместо возвращения статусного сообщения (AV1200) ![](/assets/images/2.png)

Кодовая база, которая использует возвращаемое статусное сообщение для определения завершилась ли операция успешно или нет, зачастую имеет вложенные if выражения, разбросанные по всему коду. Зачастую пользователи забывают проверить возвращаемое значение. Структурированная обработка исключений была введена для того, чтобы позволить вам генерировать исключения и отлавливать или заменять их на более высоком уровне. В большинстве систем является довольно распространенной практикой генерировать исключения всякий раз, когда происходит неожиданная ситуация.

### <a name="av1202"></a> Обеспечьте полное и осмысленное сообщение об исключении (AV1202) ![](/assets/images/2.png)

Сообщение должно объяснять, что привело к исключению и ясно описывать, что нужно сделать, чтобы избежать его в дальнейшем.

### <a name="av1205"></a> Бросайте настолько специфичное исключение, насколько это возможно (AV1205) ![](/assets/images/3.png)

Например, если метод принял в качестве входного параметра `null`, следует сгенерировать `ArgumentNullException` вместо `ArgumentException` — его базового типа..

### <a name="av1210"></a> Не игнорируйте ошибку путем обработки общих исключений (AV1210) ![](/assets/images/1.png)

Не игнорируйте ошибки путем обработки общих исключений, таких как `Exception`, `SystemException` и другие в коде приложения. Только обработчик ошибок самого верхнего уровня должен отлавливать общие исключения с целью логирования и корректного завершения работы приложения.

### <a name="av1215"></a> Обрабатывайте исключения в асинхронном коде должным образом (AV1215) ![](/assets/images/2.png)

Когда вы генерируете или обрабатываете исключения в коде, который использует `async`/`await` или `Task`, помните о следующих двух правилах:

- Исключения, которые возникают в пределах блоков `async`/`await` и внутри `Task` распространяются на задачу, которая ожидает выполнение этих блоков.
- Исключения, которые возникли в коде, предшествующем `async/await` и `Task`, распространяются на вызывающий код

### <a name="av1220"></a> Всегда проверяйте делегат обработчика события на  `null` (AV1220) ![](/assets/images/1.png)

Событие, которое не имеет подписок, равно `null`. Таким образом, перед тем, как оно будет вызвано, убедитесь, что список делегатов, представляющих это событие, не равен `null`.

	event EventHandler<NotifyEventArgs> Notify;

	protected virtual void OnNotify(NotifyEventArgs args)
	{
		Notify?.Invoke(this, args);
	}

### <a name="av1225"></a> Для обработки каждого события используйте защищенный виртуальный метод (AV1225) ![](/assets/images/2.png)

Выполнение этой рекомендации позволит производным классам обрабатывать событие базового класса путем переопределения защищенного метода. Название защищенного виртуального метода должно быть таким же, как название события, но с префиксом On. Например, защищенный виртуальный метод для события с названием `TimeChanged` должен быть назван `OnTimeChanged`.

**Примечание:**  От производных классов, которые переопределяют защищенный виртуальный метод, не требуется вызывать реализацию базового класса. Базовый класс должен продолжать свою работу корректно, даже если его реализация не вызвана.

### <a name="av1230"></a> Использование событий уведомления об изменении свойств (AV1230) ![](/assets/images/3.png)

Событие уведомления об изменении свойства должно иметь название наподобие `PropertyChanged`, где `Property` должно быть изменено на название свойства, с которым связано это событие.

**Примечание:** Если ваш класс имеет множество свойств, которые требуют соответствующих событий, попробуйте реализовать вместо этого интерфейс `INotifyPropertyChanged`. Он часто используется в паттернах [Presentation Model](http://martinfowler.com/eaaDev/PresentationModel.html) и [Model-View-ViewModel](http://msdn.microsoft.com/en-us/magazine/dd419663.aspx).

### <a name="av1235"></a> Не отправляйте `null` в качестве аргумента при вызове события (AV1235) ![](/assets/images/1.png)

Зачастую обработчик событий используется для обработки схожих событий от множества отправителей. В таком случае передаваемый аргумент используется для того, чтобы передать контекст вызова события. Всегда отправляйте ссылку на контекст (обычно `this`) при вызове события. Кроме того, не отправляйте `null` при вызове события, если оно не имеет данных. Если событие не имеет данных, отправьте `EventArgs`.Empty вместо `null`.

**Исключение:** Для статических событий передаваемый аргумент должен быть `null`.

### <a name="av1240"></a> Используйте общие ограничения, если возможно (AV1240) ![](/assets/images/2.png)

Вместо приведения и преобразования типа из конкретного в общий и наоборот используйте ключевое слово `where` или оператор `as`, чтобы привести объект к конкретному типу. Например: 

	class SomeClass  
	{}
	
	// Неправильно
	class MyClass  
	{
		void SomeMethod(T t)  
		{  
			object temp = t;  
			SomeClass obj = (SomeClass) temp;  
		}  
	}
	
	// Правильно  
	class MyClass where T : SomeClass  
	{
		void SomeMethod(T t)  
		{  
			SomeClass obj = t;  
		}  
	}

### <a name="av1250"></a> Вычисляйте результат LINQ-запроса до того, как вернуть его (AV1250) ![](/assets/images/1.png)

Посмотрите на следующий код:

	public IEnumerable<GoldMember> GetGoldMemberCustomers()
	{
		const decimal GoldMemberThresholdInEuro = 1_000_000;
		
		var query = 
			from customer in db.Customers
			where customer.Balance > GoldMemberThresholdInEuro
			select new GoldMember(customer.Name, customer.Balance);
		
		return query;  
	}

Поскольку LINQ-запросы используют отложенное выполнение, возвращение `q`, как это ни странно, вернет древо выражения, представляющее вышеуказанный запрос. Всякий раз, когда пользователь вычисляет результат, используя `foreach` или что-то похожее, весь запрос выполняется заново, создавая каждый раз новые экземпляры `GoldMember`. Как следствие, вы не сможете использовать оператор `==`, чтобы сравнить различные экземпляры `GoldMember`. Вместо этого всегда явно вычисляйте результат LINQ-запроса, используя `ToList()`, `ToArray()` или схожие методы.

### <a name="av1251"></a> Используйте префиксы `this` и `base` только тогда когда это необходимо (AV1251) ![](/assets/images/1.png)

Используя иерархию классов, совсем необязательно знать на каком уровне определен используемый метод. Дочерние классы труднее изменить, если этот уровенть зафиксирован в коде.
