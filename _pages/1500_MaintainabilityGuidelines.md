---
title: Рекомендации по улучшению сопровождаемости кода
permalink: /maintainability-guidelines/
classes: wide
search: true
sidebar:
  nav: "sidebar"
---

### <a name="av1500"></a> В методе не должно быть более 7 объявлений (AV1500) ![](/assets/images/1.png)
Метод, который включает в себя более 7 объявлений, скорей всего делает слишком много или берет на себя слишком большую ответственность. Кроме того, человеческая память требует, чтобы метод был коротким. Она не в состоянии удерживать в себе одновременно большее количество вещей, чтобы точно проанализировать и понять, что делает тот или иной кусок кода. Разделите метод на несколько маленьких, имеющих четкое предназначение, и дайте им имена, которые будут точно указывать на то, что они делают. При этом обратите внимание на то, чтобы алгоритм работы этой части программы оставался ясен для понимания. 

### <a name="av1501"></a> Создавайте все члены класса `private` а типы `internal sealed` по умолчанию (AV1501) ![](/assets/images/1.png)
Чтобы принять более взвешенное решение о том, какие элементы должны быть доступны другим классам, в первую очередь как можно больше ограничьте их область видимости. Затем тщательно подумайте, какие члены или типы действительно стоит сделать public.

### <a name="av1502"></a> Избегайте двойного отрицания (AV1502) ![](/assets/images/2.png)
Несмотря на то, что такое свойство, как `customer.HasNoOrders` имеет право на существование, избегайте его использования с отрицанием. Например:

	bool hasOrders = !customer.HasNoOrders;

Двойное отрицание более сложно для понимания, чем простое выражение, и люди склонны путаться в нем.

### <a name="av1505"></a> Именуйте сборку по имени пространства имен, которое она содержит (AV1505) ![](/assets/images/3.png)
Все сборки должны быть названы на основании паттерна *Company*.*Component*.dll. Где *Company* - название вашей фирмы, а *Component* содержит один или более разделенных точкой названия. Например `AvivaSolutions.Web.Controls.dll`.

Например, есть группа классов в неймспейсе `AvivaSolutions.Web.Binding` находящаяся в сборке. На основании рекомендаций, эта сборка должна называться `AvivaSolutions.Web.Binding.dll`.

**Исключение:** Если вы решите связать классы из различных несвязанных пространств имен в одну сборку, добавьте суффикс `Core` к ее названию. Однако не используйте этот суффикс в названиях пространств имен. Например: `AvivaSolutions.Consulting.Core.dll`.

### <a name="av1506"></a> Называйте файлы с исходным кодом в соответствии с тем типом данных, который он содержит (AV1506) ![](/assets/images/3.png)
Используйте нотацию паскаль для именования файлов и не используйте подчеркивания. Не включайте названия обобщенных параметров в название файла.

### <a name="av1507"></a> Ограничивайте содержимое файла с исходным кодом одним типом данных (AV1507) ![](/assets/images/3.png)
**Исключение:** Вложенные типы должны быть частью того же самого файла.

**Исключение:** Типы, которые отличаются количеством обобщенных параметров должны быть частью одного и того же файла.

### <a name="av1508"></a> Наименование файла с исходным кодом, который содержит частичный тип данных, должно отражать назначение этой части (AV1508) ![](/assets/images/3.png)
Когда используются частичные типы и идет разделение частей на файлы, имя каждого файла должно быть логически разделено на две части. Первая часть – название типа. Вторая – роль, которую данный фрагмент играет в типе. Например:

	// В MyClass.cs
	public partial class MyClass
	{...}
	
	// В MyClass.Designer.cs	
	public partial class MyClass
	{...}

### <a name="av1510"></a> Используйте `using` вместо указания полной ссылки на тип из другого пространства имен (AV1510) ![](/assets/images/3.png)
Не используйте полную ссылку на тип из другого пространства имен в целях предотвращения конфликтов именования. Например, не делайте так:

	var list = new System.Collections.Generic.List<string>();

Лучше сделать так:

	using System.Collections.Generic;
	
	var list = new List<string>();

Если вам необходимо избежать конфликтов именования, используйте директиву using для создания псевдонима пространства имен или типа:

	using Label = System.Web.UI.WebControls.Label;

### <a name="av1515"></a> Не используйте «магические» числа (AV1515) ![](/assets/images/1.png)
Не используйте литеральные значения, числа или строки в вашем коде ни для чего другого, кроме как для объявления констант. Для примера:

	public class Whatever  
	{
		public static readonly Color PapayaWhip = new Color(0xFFEFD5);
		public const int MaxNumberOfWheels = 18;
		public const byte ReadCreateOverwriteMask = 0b0010_1100;
	}

Строки, предназначенные для логирования или трассировки, являются исключением из этого правила. Литеральные значения допускается использовать только тогда, когда их смысл ясен из контекста и их не планируется изменять. Например:

	mean = (a + b) / 2; // среднее арифметическое
	WaitMilliseconds(waitTimeInSeconds * 1000); //  тут тоже все понятно

Если значение одной константы зависит от значения другой, укажите это явно в своем коде.

	public class SomeSpecialContainer  
	{  
		public const int MaxItems = 32;  
		public const int HighWaterMark = 3 * MaxItems / 4; // 75%  
	}

**Заметка:** Перечисления часто могут использоваться в качестве хранилища символьных констант. 

### <a name="av1520"></a> Используйте `var` только тогда, когда тип переменной очевиден (AV1520) ![](/assets/images/1.png)
Используйте `var` только в том случае, если переменной присваивается результат LINQ-запроса или если тип переменной очевиден и использование var повысит читаемость кода. Например, так делать не стоит:

	var item = 3;                              // Что за тип? int? uint? float?
	var myfoo = MyFactoryMethod.Create("arg"); // Не понятно, какой тип имеет 			
	                                           // класс или интерфейс. Кроме того,
	                                           // тяжело изменять код, который работает
	                                           // c этой переменной, если исходный класс
											   // вам недоступен

Вместо этого используйте `var` как в примерах ниже:

	var query = from order in orders where order.Items > 10 and order.TotalValue > 1000;
	var repository = new RepositoryFactory.Get();	
	var list = new ReadOnlyCollection();

Во всех трех примерах тип присваиваемых переменным значений очевиден. Для получения более подробной информации об использовании `var` читайте статью Ерика Липперта [Использование и злоупотребление неявной типизацией](http://blogs.msdn.com/b/ericlippert/archive/2011/04/20/uses-and-misuses-of-implicit-typing.aspx).

### <a name="av1521"></a> Объявляйте и инициализируйте переменные как можно позже (AV1521) ![](/assets/images/2.png)
Избегайте стиля языков C и VisualBasic, когда все переменные объявляются в начале блока. Объявляйте и инициализируйте каждую переменную только тогда, когда она необходима.

### <a name="av1522"></a> Присваивайте значение каждой переменной в отдельном объявлении (AV1522) ![](/assets/images/1.png)
Никогда не делайте так:

	var result = someField = GetSomeMethod();

**Исключение:** Присваивание значений нескольким переменным разрешено только в случае использования `out` переменных, is-паттерна или преобразования в `Tuple`.

	bool success = int.TryParse(text, out int result);
	
	if ((items[0] is string text) || (items[1] is Action action))
	{
	}

	(string name, string value) = SplitNameValuePair(text);

### <a name="av1523"></a> Предпочитайте инициализаторы объектов и коллекций раздельной установке свойств и раздельному добавлению новых объектов в коллекцию (AV1523) ![](/assets/images/2.png)
Вместо такой конструкции:

	var startInfo = new ProcessStartInfo("myapp.exe");	
	startInfo.StandardOutput = Console.Output;
	startInfo.UseShellExecute = true;

	var countries = new List();
	countries.Add("Netherlands");
	countries.Add("United States");

	var countryLookupTable = new Dictionary<string, string>();
	countryLookupTable.Add("NL", "Netherlands");
	countryLookupTable.Add("US", "United States");

Используйте [инициализатор объекта или коллекции](http://msdn.microsoft.com/en-us/library/bb384062.aspx):

	var startInfo = new ProcessStartInfo("myapp.exe")  
	{
		StandardOutput = Console.Output,
		UseShellExecute = true  
	};
	
	var countries = new List { "Netherlands", "United States" };
	
	var countryLookupTable = new Dictionary<string, string>
	{
		["NL"] = "Netherlands",
		["US"] = "United States"
	};

### <a name="av1525"></a> Не производите явного сравнения с `true` или `false` (AV1525) ![](/assets/images/1.png)
Сравнение логического значения с `true` или `false` – это, как правило, плохой стиль программирования. В качестве примера:

	while (condition == false) // неправильно, плохой стиль  
	while (condition != true) // тоже неправильно  
	while (((condition == true) == true) == true) // где ты остановишься?   
	while (condition) // OK

### <a name="av1530"></a> Не изменяйте переменную цикла внутри тела цикла (AV1530) ![](/assets/images/2.png)
Изменение переменной цикла в теле цикла как правило сбивает с толку. Особенно, если переменная изменяется более чем в одном месте.

	for (int index = 0; index < 10; ++index)  
	{  
		if (someCondition)
		{
			index = 11; // Неправильно! Вместо этого используйте ‘break’ или ‘continue’  
		}
	}

### <a name="av1532"></a> Избегайте вложенных циклов (AV1532) ![](/assets/images/2.png)
Методы, содержащие вложенные циклы, более сложны для понимания, чем те, которые содержат только один цикл. В большинстве случаев циклы могут быть заменены гораздо меньшим по размеру LINQ-запросом, который использует ключевое слово `from` два раза и более для объединения данных.

### <a name="av1535"></a> Всегда используйте конструкции `if`, `else`, `do`, `while`, `for`, `foreach` и `case` с фигурными скобками (AV1535) ![](/assets/images/2.png)
Пожалуйста, обратите внимание, что это также поможет избежать возможной путаницы с конструкциями вроде этой:

	if (isActive) if (isVisible) Foo(); else Bar(); // к какому ‘if’ относится ‘else’?
	
	// Лучше сделать так:  
	if (isActive)  
	{  
		if (isVisible)  
		{  
			Foo();  
		}  
		else  
		{  
			Bar();  
		}  
	}

### <a name="av1536"></a> Всегда используйте блок `default` в конце конструкции `switch/case` (AV1536) ![](/assets/images/1.png)
Если блок `default` будет пуст, добавьте поясняющий комментарий. Кроме того, если этот блок не должен быть достижимым, сгенерируйте при его вызове `InvalidOperationException`, чтобы обнаружить будущие изменения, при которых ни один из блоков case не будет достигнут. Следование этой рекомендации позволит вам писать более чистый код, потому что все сценарии выполнения уже были продуманы.

	void Foo(string answer)  
	{  
		switch (answer)  
		{  
			case "no":  
			{
			  Console.WriteLine("You answered with No");  
			  break;
			}  
			  
			case "yes":
			{  
			  Console.WriteLine("You answered with Yes");  
			  break;
			}
			
			default:  
			{
			  // Not supposed to end up here.  
			  throw new InvalidOperationException("Unexpected answer " + answer);
			}  
		}  
	}

### <a name="av1537"></a> Заканчивайте каждый блок `if-else-if` объявлением `else` (AV1537) ![](/assets/images/2.png)
Например:

	void Foo(string answer)  
	{  
		if (answer == "no")  
		{  
			Console.WriteLine("You answered with No");  
		}  
		else if (answer == "yes")  
		{  
			Console.WriteLine("You answered with Yes");  
		}  
		else  
		{  
			// Что должно случиться, когда этот блок выполнится? Игнорировать это? 
            // Если нет, то  сгенерировать исключение InvalidOperationException.
		}  
	}

### <a name="av1540"></a> Старайтесь избегать нескольких объявлений `return` (AV1540) ![](/assets/images/2.png)
Один вход — одна точка выхода, так звучит этот принцип. Он позволяет поддерживать понятным ход выполнения метода. При этом если метод очень маленький и соответствует рекомендации [AV1500](#av1500), тогда несколько объявлений return могут быть актуальными и улучшат читаемость кода. Например, если метод возвращает логическое значение, удобней использовать два объявления return вместо логической переменной, которую вернет метод и которой будут присваиваться значения по ходу его выполнения.

### <a name="av1545"></a> Не используйте блок `if-else` вместо простого (условного) присваивания (AV1545) ![](/assets/images/2.png)
Выражайте свои намерения прямо. Например, вместо этого:

	bool isPositive;

	if (value > 0)
	{
		isPositive = true;
	}
	else
	{
		isPositive = false;
	}

Делайте так:

	bool isPositive = (value > 0);

Вместо:

	string classification;

	if (value > 0)
	{
		classification = "positive";
	}
	else
	{
		classification = "negative";
	}

	return classification;

Пишите:

	return (value > 0) ? "positive" : "negative";

Вместо:

	int result;

	if (offset == null)
	{
		result = -1;
	}
	else
	{
		result = offset.Value;
	}

	return result;

Пишите:

	return offset ?? -1;

Вместо:

	if (employee.Manager != null)
	{
		return employee.Manager.Name;
	}
	else
	{
		return null;
	}

Пишите:

	return employee.Manager?.Name;

### <a name="av1547"></a> Инкапсулируйте сложное выражение в методе или свойстве (AV1547) ![](/assets/images/1.png)
Рассмотрим следующий пример:

	if (member.HidesBaseClassMember && (member.NodeType != NodeType.InstanceInitializer))
	{
		// что-то делаем
	}

Чтобы понять, что делает этот код, вам придется вникать в его детали и предвидеть все варианты его выполнения. Конечно, вы можете добавить поясняющий комментарий перед этим кодом, но лучше замените сложное выражение методом, название которого будет говорить само за себя.

	if (NonConstructorMemberUsesNewKeyword(member))  
	{  
		// что-то делаем
	}  
  
  
	private bool NonConstructorMemberUsesNewKeyword(Member member)  
	{  
		return
			(member.HidesBaseClassMember &&
			(member.NodeType != NodeType.InstanceInitializer)  
	}

Если вам потребуется изменить этот метод, вам все равно придется разбираться в том, как он работает. Но теперь гораздо легче понять код, который его вызывает.

### <a name="av1551"></a> Вызывайте наиболее перегруженный метод из других перегрузок (AV1551) ![](/assets/images/2.png)
Данное правило применимо только к тем методам, которые перегружены между собой необязательными аргументами. Посмотрите на пример ниже:

	public class MyString  
	{
		private string someText;
		
		public int IndexOf(string phrase)  
		{  
			return IndexOf(phrase, 0); 
		}
		
		public int IndexOf(string phrase, int startIndex)  
		{  
			return IndexOf(phrase, startIndex, someText.Length - startIndex);
		}
		
		public virtual int IndexOf(string phrase, int startIndex, int count)  
		{  
			return someText.IndexOf(phrase, startIndex, count);
		}  
	}

Класс `MyString` обеспечивает три перегрузки метода `IndexOf`, при этом две их них просто вызывают другую с большим количеством параметров. Заметьте, что это правило применимо к конструкторам класса. Реализуйте наиболее перегруженный конструктор и вызывайте его из других перегрузок, используя оператор `this()`. Также следует отметить, что параметры с одними и теми же именами должны следовать в одном и том же порядке во всех перегрузках.

**Важно:** Если вы хотите, чтобы поведение классов можно было менять с помощью переопределения данных методов, то объявите наиболее перегруженный метод как protected virtual, который вызывается всеми перегрузками.

### <a name="av1553"></a> Используйте необязательные аргументы только для того, чтобы заменять перегрузки (AV1553) ![](/assets/images/1.png)
Единственная допустимая причина для использования необязательных аргументов C# 4.0 – это замена примера из правила [AV1551](#av1551) одиночным методом наподобие этого:

    public virtual int IndexOf(string phrase, int startIndex = 0, int count = -1)
    {
        int length = (count == -1) ? (someText.Length - startIndex) : count;
        return someText.IndexOf(phrase, startIndex, length);
    }

Если необязательный параметр является ссылочным типом, то он может иметь в качестве значения по умолчанию только `null`. Но, как нам известно, `string`, `list` и `collections` никогда не должны быть равны `null` согласно правилу [AV1135](/member-design-guidelines#av1135). Поэтому вы должны использовать вместо этого перегруженный метод.

**Примечание:** Компилятор копирует значение необязательных параметров в место вызова. Поэтому, изменение значения по умолчанию для необязательных параметров должно сопровождаться рекомпиляцией вызывающего кода.

**Примечание:** Когда метод интерфейса определяет необязательный параметр, его значение по умолчанию не рассматривается во время разрешения перегрузки до тех пор, пока вы не вызовите реализацию этого метода через интерфейс. См. [статью Эрика Липперта](http://blogs.msdn.com/b/ericlippert/archive/2011/05/09/optional-argument-corner-cases-part-one.aspx) для получения дополнительной интформации.

### <a name="av1555"></a> Избегайте использования именованных аргументов (AV1555) ![](/assets/images/1.png)
Именованные аргументы C# 4.0 были созданы для того, чтобы облегчить вызов COM компонентов, которые известны тем, что могут предлагать тонны необязательных параметров. Если вам нужны именованные аргументы, чтобы улучшить читаемость вызова для метода, скорее всего, этот метод делает слишком много и он должен быть подвергнут рефакторингу.

**Исключение:** Единственное исключение когда именованые аргументы могут улучшить читаемость - вызов метода, который имеет булевый параметр. 

	object[] myAttributes = type.GetCustomAttributes(typeof(MyAttribute), inherit: false);

### <a name="av1561"></a> Не допускайте, чтобы метод или конструктор принимал более трех параметров (AV1561) ![](/assets/images/1.png)
Не используйте более 3 параметров чтобы ваши конструкторы, методы, делегаты и локальные функции были небольшимм и выполняли только одну роль.

Если вы хотите передавать больше параметров, используйте структуру или класс как описано [паттерн спецификация](http://en.wikipedia.org/wiki/Specification_pattern). 
Чем меньше параметров, тем легче понимать метод. Также, юнит тестирование метода с многими параметрами требует написания множества тест кейсов. 

**Исключение:** Разрешено использовать параметр, который представляет из себя коллекцию Tuple.

### <a name="av1562"></a> Не используйте `ref` и `out` (AV1562) ![](/assets/images/1.png)
Они делают код менее понятным и создают предпосылки для ошибок. Вместо этого возвращайте составные объекты в качестве результата выполнения функции.

**Исключение:** Вызов или объявление метода который реализует паттерн [TryParse](https://docs.microsoft.com/en-us/dotnet/api/system.int32.tryparse). Например:

	bool success = int.TryParse(text, out int number);

### <a name="av1564"></a> Не создавайте методы, которые принимают в качестве параметра логическое значение (AV1564) ![](/assets/images/2.png)
Посмотрите на следующий метод:

	public Customer CreateCustomer(bool platinumLevel) {}

На первый взгляд все выглядит замечательно, но когда вы будете использовать этот метод, смысл логической переменной полностью потеряет свою ясность:

	Customer customer = CreateCustomer(true);

Обычно, если метод принимает булевый флаг в качестве параметра, то он делает более, чем одну вещь и нуждается в рефакторинге для разделения на два или более метода. Альтернативным решением является замена флага перечислением.

### <a name="av1568"></a> Не используйте параметры в качестве временных переменных (AV1568) ![](/assets/images/3.png)
Никогда не используйте параметр в качестве внутренней переменной. Даже если тип параметра может совпадать с тем типом, который вам требуется, то название, как правило, не будет отражать цели временной переменной.

### <a name="av1570"></a> Используйте `is` вместо `as` (AV1570) ![](/assets/images/1.png)
Если вы используйте 'as' для того чтобы безопасно проверить соответствие типов, всегда проверяйте результат операции на `null`. В противном случае, можно получить `NullReferenceException` позднее если объект не реализует интерфейс. Синтакс паттерн матчинга помогает избежать этого и улучшить читаемость. Например вместо этого:

	var remoteUser = user as RemoteUser;
	if (remoteUser != null)
	{
	}

Пишите:

	if (user is RemoteUser remoteUser)
	{
	}

### <a name="av1575"></a> Не оставляйте закомментированные участки кода (AV1575) ![](/assets/images/1.png)
Никогда не отправляйте в репозиторий закомментированный код. Вместо этого используйте систему трекинга задач, чтобы следить за тем, какая работа должна быть сделана. Никто впоследствии не догадается, для чего предназначен тот или иной блок закомментированного кода. Он был временно закомментирован для тестирования? Он был скопирован в качестве примера? Должен ли я удалить его?
