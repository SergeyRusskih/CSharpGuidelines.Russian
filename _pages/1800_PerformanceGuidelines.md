---
title: Рекомендации по повышению производительности
permalink: /performance-guidelines/
classes: wide
search: true
sidebar:
  nav: "sidebar"
---

### <a name="av1800"></a> Используйте `Any()`, чтобы проверить `IEnbmerable` на пустоту (AV1800) ![](/assets/images/3.png)
Если метод или другой элемент возвращает `IEnumerable` или другой класс коллекции, который не предоставляет свойство Count, используйте метод расширения `Any()` вместо `Count()`, чтобы проверить коллекцию на пустоту. Если вы используете `Count()`, то вы рискуете снизить производительность, т.к. это приведет к итерации всей коллекции (например, в случае с `IQueryable` выполнится запрос к данным).

**Примечание:** Если вы возвращаете `IEnumerable`, чтобы предотвратить изменение возвращаемой коллекции, как было рекомендовано в правиле [AV1130](/member-design-guidelines#av1130), и вы работаете с .NET 4.5 и выше, попробуйте использовать новые read-only классы.

### <a name="av1820"></a> Используйте `async` только для долговременных и низкоинтенсивных задач (AV1820) ![](/assets/images/1.png)
Использование `async` не запустит автоматически что-нибудь в рабочем потоке, как это делает `Task.Run`. `Async`, просто добавляет необходимую логику, которая служит для того, чтобы разрешить высвобождать текущий поток и вернуть результат на тот же поток после завершения асинхронной операции. Другими словами, используйте `async` только для операций, связанных с I/O.

### <a name="av1825"></a> Используйте `Task.Run` для высокоинтенсивных задач (AV1825) ![](/assets/images/1.png)
Если вам нужно выполнить операцию, связанную с выделением дополнительных ресурсов процессора, используйте `Task.Run`, чтобы выгрузить работу на поток из пула потоков. Просто не забывайте о том, что вам придется вручную возвращать результат в ваш основной поток.

### <a name="av1830"></a> Избегайте использования `await/async` с `Task.Wait` (AV1830) ![](/assets/images/1.png)
`await` не заблокирует текущий поток, а просто проинформирует компилятор о необходимости построения машины состояний. Однако `Task.Wait` заблокирует поток и даже может привести к взаимным блокировкам (смотрите [AV1835](#av1835)).

### <a name="av1835"></a> Опасайтесь взаимной блокировки `async/await` в однопоточном окружении  (AV1835) ![](/assets/images/1.png)
Рассмотрим следующий асинхронный метод:

	private async Task GetDataAsync()
	{
		var result = await MyWebService.GetDataAsync();
		return result.ToString();
	}

Затем вызовете его в методе контроллера ASP.NET MVC следующим образом:

	public ActionResult ActionAsync()
	{
		var data = GetDataAsync().Result;
		
		return View(data);  
	}

Здесь вы получите взаимную блокировку. Почему? Потому что геттер свойства `Result` будет блокировать поток до тех пор, пока операция `async` не будет завершена, но поскольку метод `async` будет автоматически возвращать результат на оригинальный поток, а ASP.NET использует однопоточный контекст синхронизации, они будут продолжать ждать друг друга. Похожая проблема также может возникнуть с WPF, Silverlight или с C#/XAML приложениями Windows Store. Вы можете узнать об этом больше [здесь](http://blogs.msdn.com/b/pfxteam/archive/2011/01/13/10115163.aspx).
