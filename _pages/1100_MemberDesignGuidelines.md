---
title: Рекомендации по проектированию членов класса
permalink: /member-design-guidelines/
classes: wide
search: true
sidebar:
  nav: "sidebar"
---

### <a name="av1100"></a> Свойства класса должны иметь возможность быть установленными в любом порядке (AV1100) ![](/assets/images/1.png)

Свойства не должны зависеть от других свойств. Другими словами, не должно быть разницы в том, какое свойство мы устанавливаем в первую очередь. Например, сначала `DataSouse`, затем `DataMember` или наоборот. 

### <a name="av1105"></a> Используйте метод вместо свойства (AV1105) ![](/assets/images/3.png)

- Если происходит что-то большее, чем установка значения поля.
- Если свойство представляет из себя конвертацию. Например, метод `Object.ToString`.
- Если свойство возвращает различные значения для каждого вызова, даже если аргументы при этом не изменяются. Например, метод `NewGuid` будет каждый раз возвращать новое значение.
- Если использование свойства вызывает побочный эффект. Например, изменение внутреннего состояния, которое не имеет прямого отношения к свойству (это нарушает [Command Query Separation](http://martinfowler.com/bliki/CommandQuerySeparation.html) принцип). 

**Исключение:** Заполнение внутреннего кэша или реализация [lazy-loading](http://www.martinfowler.com/eaaCatalog/lazyLoad.html) являются хорошими исключениями из этого правила.

### <a name="av1110"></a> Не используйте взаимоисключающие свойства (AV1110) ![](/assets/images/1.png)

Если у вас имеются свойства, которые не могут быть использованы в одно и то же время, то это значит, что они представляют из себя две взаимоисключающие концепции. Даже если эти концепции могут иметь некоторую общую логику и состояние, то очевидно, что они имеют различные правила, которые не сочетаются друг с другом.

Нарушение этого правила часто можно встретить в доменной модели, когда свойства инкапсулируют в себе всевозможные виды условной логики, содержащей взаимоисключающие правила. Это зачастую вызывает эффект волны и обслуживание такого кода становится более трудоемким. 

### <a name="av1115"></a> Метод или свойство должны иметь единственное предназначение (AV1115) ![](/assets/images/1.png)

Так же, как и класс [AV1000](/class-design-guidelines#av1000), каждый метод должен иметь одну зону ответственности.

### <a name="av1125"></a> Не выставляйте объекты, описывающие состояние, посредством статических членов (AV1125) ![](/assets/images/2.png)

Объекты с состоянием (stateful object) – это объекты, которые содержат в себе множество свойств и логики, которую эти свойства инкапсулируют. Если вы выставите такой объект через статическое свойство или метод другого объекта, то будут плохо поддаваться рефакторингу и юнит-тестированию классы, которые зависят от объекта с состоянием. В общем случае, использование описанной выше конструкции – отличный пример нарушения множества рекомендаций, описанных в этой главе.

Классическим примером служит свойств `HttpContext.Current` в ASP.NET. Многие смотрят на класс `HttpContext` как на источник большого количества грязного кода. По факту, одно из правил тестирования – [изолируйте уродливые вещи (Isolate the Ugly Stuff)](http://codebetter.com/jeremymiller/2005/10/21/haacked-on-tdd-and-jeremys-first-rule-of-tdd/) ) — часто относится к этому классу.

### <a name="av1130"></a> Возвращайте `IEnumerable<T>` или `ICollection<T>` вместо какой-либо конкретной коллекции (AV1130) ![](/assets/images/2.png)

Если вы не хотите, чтобы пользователи могли изменять коллекцию, не возвращайте массив, лист или другой класс коллекции напрямую. Вместо этого возвращайте `IEnumerable<T>`, или, если пользователю требуется знать количество элементов в коллекции, `ICollection<T>`.

**Заметка:**  Если вы используете .Net 4.5 и выше, вы также можете применять `IReadOnlyCollection<T>`, `IReadOnlyList<T>` или `IReadOnlyDictionary<TKey, TValue>`.

**Исключение:** Неизменяемые коллекции, такие как `ImmutableArray<T>`, `ImmutableList<T>` и `ImmutableDictionary<TKey, TValue>` также запрещают модификацию.

### <a name="av1135"></a> Свойства, методы или аргументы, которые представляют из себя строку или коллекцию, никогда не должны быть равны `null` (AV1135) ![](/assets/images/1.png)

Возвращение `null` как результат выполнения метода, может быть неожиданностью для пользователя. Всегда возвращайте пустую коллекцию или пустую строку вместо нулевой ссылки. При использовании `Task` или `Task<T>`, верните `Task.CompletedTask` или `Task.FromResult()`. Кроме всего прочего, это избавит вас от необходимости засорять ваш код дополнительными проверками на`null` или, что еще хуже, использовать, `string.IsNullOrEmpty()`.

### <a name="av1137"></a> Определяйте параметры настолько специфичными, насколько это возможно (AV1137) ![](/assets/images/2.png)

Если элемент класса в качестве параметров требует часть данных другого класса, определяйте типы данных этих параметров как можно более конкретными и не принимайте в качестве параметра весь объект целиком. Например, рассмотрим метод, который в качестве параметра требует передать строку подключения, описанную в некоем центральном интерфейсе IConfiguration. Вместо того, чтобы в качестве параметра принимать весь объект, реализующий этот интерфейс, передайте только строку подключения. Это не только позволит вам уменьшить количество зависимостей в коде, но и улучшит его сопровождаемость в отдаленной перспективе.

**Заметка:** Другими словами *Не используйте грузовик если вам нужно отправить всего лишь посылку*.

### <a name="av1140"></a> Используйте типы, характерные для вашей предметной области, вместо примитивов (AV1140) ![](/assets/images/3.png)

Вместо использования строк, целых и дробных чисел для представления таких специфичных типов, как ISBN (международный стандартный книжный номер), адрес электронной почты или денежной суммы, создавайте объекты на каждый тип, которые будут включать в себя как сами данные, так и правила валидации, которые будут к ним применяться. Делая так, вам удастся избежать множественных реализаций одних и тех же бизнес-правил. Это улучшит сопровождаемость вашего кода и уменьшит количество багов.