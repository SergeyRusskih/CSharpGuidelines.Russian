---
title: Рекомендации по проектированию классов
permalink: /class-design-guidelines/
classes: wide
search: true
sidebar:
  nav: "sidebar"
---

### <a name="av1000"></a> Класс или интерфейс должны иметь единственное предназначение (AV1000) ![](/assets/images/1.png)

Класс или интерфейс должен иметь единственное предназначение в рамках системы, в которой он используется. Как правило, класс служит одной из целей: либо он описывает тип, например, email или ISBN (международный стандартный книжный номер), либо представляет из себя абстракцию некоторой бизнес-логики, либо он описывает структуру данных, либо отвечает за взаимодействие между другими классами. Он никогда не должен в себе комбинировать эти задачи. Это правило известно как [Правило Единой Ответственности](https://8thlight.com/blog/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html), одно из принципов SOLID.

**Совет:** Класс со словом `And` в названии — это явное нарушение данного правила.

**Совет:** Используйте [Паттерны проектирования](http://en.wikipedia.org/wiki/Design_pattern_(computer_science)) для взаимодействия между классами. Если вам не удается применить ни один из паттернов к классу, возможно, он берет на себя слишком большую ответственность.

**Примечание** Если вы создаете класс, который описывает тип, вы можете значительно упростить его использование, если сделаете его неизменяемым.

### <a name="av1001"></a> Создавайте новые экземпляры класса с помощью конструктора таким образом, чтобы в результате вы получили полностью готовый к использованию объект (AV1001) ![](/assets/images/3.png)

Созданный объект не должен нуждаться в установке дополнительных свойств перед использованием в каких бы целях его не планировалось бы применять. При этом если конструктор нуждается в более чем трех параметрах (что нарушает [AV1561](/maintainability-guidelines#av1561)), возможно, что класс берет на себя слишком большую ответственность (нарушение правила [AV1000](#av1000)).

### <a name="av1003"></a> Интерфейс должен быть небольшим и должен быть сфокусирован на решении одной задачи (AV1003) ![](/assets/images/2.png)

Интерфейс должен иметь имя, которое ясно описывает его предназначение или роль, которую он выполняет в системе. Не объединяйте слабо связанные элементы в один интерфейс только потому, что они относятся к одному классу. Формируйте интерфейсы на основании функциональности, за которую отвечают вызываемые методы или на основе конкретной задачи, которую этот интерфейс выполняет. Это правило более известно как [Принцип сегрегации интерфейса](https://lostechies.com/wp-content/uploads/2011/03/pablos_solid_ebook.pdf).

### <a name="av1004"></a> Используйте интерфейс, а не базовый класс, чтобы поддерживать несколько реализаций (AV1004) ![](/assets/images/3.png)

Если вы хотите выставить точку расширения вашего класса, выставляйте его в качестве интерфейса, а не базового класса. Вам не захочется заставлять пользователей этой точки расширения делать свои реализации на основе базового класса, который может вести себя нежелательным образом. Впрочем, для их удобства вы можете создать реализацию по умолчанию (абстрактный класс), которая может служить в качестве отправной точки.

### <a name="av1005"></a> Используйте интерфейс для реализации слабой связанности между классами (AV1005) ![](/assets/images/2.png)

Интерфейсы – это отличный инструмент для реализации слабой связанности между классами:

- Они помогают избежать двунаправленной связанности; 
- Они упрощают замену одной реализации другой; 
- Они позволяют заменить недоступный внешний сервис или ресурс временной заглушкой для использования в нерабочем окружении;
- Он позволяет заменить текущую реализацию фиктивной при модульном тестировании; 
- Используя фреймворк для внедрения инъекции зависимостей, вы можете собрать в одном месте логику выбора класса в зависимости от запрашиваемого интерфейса;

### <a name="av1008"></a> Избегайте статических классов (AV1008) ![](/assets/images/3.png)

За исключением статических классов, которые используются для создания методов расширений, статические классы очень часто приводят к плохому коду. К тому же их очень сложно, если вообще возможно, тестировать в изоляции до тех пор, пока вы не прибегнете к каким-либо очень изощренным инструментам.

**Примечание:** Если вам действительно необходим статический класс, пометьте его как static. В этом случае компилятор запретит создание экземпляров этого класса и инициализирует ваш класс перед первым обращением к нему. Это избавит вас от необходимости использовать приватный конструктор. 

### <a name="av1010"></a> Не подавляйте предупреждения компилятора с помощью ключевого слова `new` (AV1010) ![](/assets/images/1.png)

Предупреждения компилятора [CS0114](https://docs.microsoft.com/en-us/dotnet/csharp/misc/cs0114) появляются при нарушении [Полиморфизма](http://en.wikipedia.org/wiki/Polymorphism_in_object-oriented_programming), одного из наиболее значимых правил объектно-ориентированного программирования.
Это проедупреждения всегда появляется при использовании ключевого слова `new` и делает дочерние классы сложными для понимания. Посмотрите на следующий пример:

	public class Book  
	{
		public virtual void Print()  
		{
			Console.WriteLine("Printing Book");
		}  
	}
	
	public class PocketBook : Book  
	{
		public new void Print()
		{
			Console.WriteLine("Printing PocketBook");
		}  
	}
	
Это влечет за собой повоедение которе обычно не ожидают от иерархии классов:

	PocketBook pocketBook = new PocketBook();
	
	pocketBook.Print(); // Outputs "Printing PocketBook "
	
	((Book)pocketBook).Print(); // Outputs "Printing Book"

Здесь показано, что метод `Print()` имеет различное поведение в зависимости от того, вызывается ли он через ссылку на базовый класс или был вызван в качестве метода производного класса.

### <a name="av1011"></a> Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом (AV1011) ![](/assets/images/2.png)

Другими словами, поведение наследуемых классов не должно противоречить поведению, заданному базовым классом, то есть поведение наследуемых классов должно быть ожидаемым для кода, использующего переменную базового типа. Наиболее известным примером нарушения этого правила является исключение `NotImplementedExeption`, когда оно возникает при переопределении метода базового класса. 

**Примечание:** Этот принцип также известен как Принцип подстановки Барбары Лисков, один из [S.O.L.I.D.](http://www.lostechies.com/blogs/chad_myers/archive/2008/03/07/pablo-s-topic-of-the-month-march-solid-principles.aspx) принципов.

### <a name="av1013"></a> Не ссылайтесь на производные классы из базового класса (AV1013) ![](/assets/images/1.png)

Наличие зависимостей в родительском классе от его дочерних классов нарушает принципы объектно-ориентированного программирования и не дает возможности другим разработчикам наследоваться от вашего базового класса.

### <a name="av1014"></a> Объект должен обладать ограниченным знанием о других объектах, которые не имеют непосредственного отношения к этому объекту (AV1014) ![](/assets/images/2.png)

Если ваш код напоминает код, который приведен ниже, то вы нарушаете [Закон Деметры](http://en.wikipedia.org/wiki/Law_of_Demeter).

	someObject.SomeProperty.GetChild().Foo()

Объект не должен открывать доступ к классам, от которых он зависит, потому что объекты-пользователи могут неправильно использовать свойства и методы для получения доступа к объектам, находящимся за ним. Делая так, вы позволяете вызываемому коду объединиться в одно целое с классом, который вы используйте. Таким образом, вы ограничиваете возможность замены одной реализации на другую в будущем.

**Примечание:** Использование класса, реализующего паттерн [Текучий интерфейс](http://en.wikipedia.org/wiki/Fluent_interface) может показаться нарушением данного правила. Но вызываемые методы просто передают контекст вызова следующему звену. Таким образом, это не вызывает противоречий.

**Исключение:** При использовании инверсии управления и фреймворков инъекции зависимостей часто требуется, чтобы зависимости выставлялись в качестве публичных свойств. До тех пор пока эти свойства не используются ни для чего другого, кроме как реализации инъекции зависимостей, я бы не стал рассматривать это как нарушение правила.

### <a name="av1020"></a> Избегайте двунаправленной зависимости (AV1020) ![](/assets/images/1.png)

Двунаправленная зависимость означает, что два класса знают о публичных методах друг друга или зависят от внутреннего поведения друг друга. Рефакторинг или замена одного из этих двух классов требуют изменений в обоих классах и могут повлечь за собой много непредвиденной работы. Наиболее очевидное решение – это создание интерфейса для одного из этих классов и использование инъекции зависимостей.

**Исключение:**  Доменные модели (Domain Model), применяемые в [проектировании на основе доменной области (Domain-Driven Design)](http://domaindrivendesign.org/) могут использовать двунаправленные зависимости, описывающие ассоциации из реального мира. В таких случаях я стараюсь удостовериться, что они действительно необходимы, и по мере возможности пытаюсь их избегать.

### <a name="av1025"></a> Классы должны иметь состояние и поведение (AV1025) ![](/assets/images/1.png)

Если в вашем репозитории находится множество классов, которые служат только для описания данных, то, скорей всего, у вас есть несколько классов (статических), содержащих в себе много логики обработки этих данных (смотрите [AV1008](#av1008)). Используйте принципы объектно-ориентированного программирования согласно рекомендациям в этом разделе, переместите вашу логику обработки данных к тем данным, которые ей используются.

**Исключение:**  Единственным исключением из этого правила являются классы, используемые для передачи данных между подсистемами приложения, также называемые [Data Transfer Objects](http://martinfowler.com/eaaCatalog/dataTransferObject.html), или классы, служащие оберткой для параметров метода.

### <a name="av1026"></a> Классы должны защищать консистентность своего внутреннего состояния (AV1026) ![](/assets/images/1.png)

Проверяйте передаваемыe параметры в публичных методах. Например:

	public void SetAge(int years)
	{
		AssertValueIsInRange(years, 0, 200, nameof(years));
		
		this.age = years;
	}

Проверяйте внутренне состояние. Например:

	public void Render()
	{
		AssertNotDisposed();
		
		// ...
	}
