<!--
NOTE: Requires Markdown Extra. See http://michelf.ca/projects/php-markdown/extra/
 --> 

# 7. Рекомендации по повышению производительности

### <a name="av1800"></a> Используйте `Any()`, чтобы проверить `IEnbmerable` на пустоту (AV1800) ![](images/3.png)
Если метод или другой элемент возвращает `IEnumerable<T>` или другой класс коллекции, который не предоставляет свойство `Count`, используйте метод расширения `Any()` вместо `Count()`, чтобы проверить коллекцию на пустоту. Если вы используете `Count()`, то вы рискуете снизить производительность, т.к. это приведет к итерации всей коллекции (например, в случае с `IQueryable<T>` выполнится запрос к данным).

**Примечание:** Если вы возвращаете `IEnumerable<T>`, чтобы предотвратить изменение возвращаемой коллекции, как было рекомендовано в правиле AV1130, и вы работаете с .NET 4.5 и выше, попробуйте использовать новые read-only классы.

### <a name="av1820"></a> Используйте `async` только для долговременных и низкоинтенсивных задач (AV1820) ![](images/1.png)
Использование `async` не запустит автоматически что-нибудь в рабочем потоке, как это делает `Task.Run`. `Async`, просто добавляет необходимую логику, которая служит для того, чтобы разрешить высвобождать текущий поток и вернуть результат на тот же поток после завершения асинхронной операции. Другими словами, используйте `async` только для операций, связанных с вводом/выводом.

### <a name="av1825"></a> Используйте `Task.Run` для высокоинтенсивных задач (AV1825) ![](images/1.png)
Если вам нужно выполнить операцию, связанную с выделением дополнительных ресурсов процессора, используйте `Task.Run`, чтобы выгрузить работу на поток из пула потоков. Просто не забывайте о том, что вам придется вручную возвращать результат в ваш основной поток.

### <a name="av1830"></a>  Избегайте использования `await`/`async` c `Task.Wait` (AV1830) ![](images/1.png)
`await`  не заблокирует текущий поток, а просто проинформирует компилятор о необходимости построения машины состояний. Однако `Task.Wait`  заблокирует поток и даже может привести к взаимным блокировкам (см. AV1835).

### <a name="av1835"></a> Опасайтесь взаимной блокировки `async`/`await` в однопоточном окружении (AV1835) ![](images/1.png)
Рассмотрим следующий асинхронный метод:

	private async Task GetDataAsync()
	{
		var result = await MyWebService.GetDataAsync();
		return result.ToString();
	}

Затем вызовете его в методе контроллера ASP.NET MVC следующим образом:

	public ActionResult ActionAsync()
	{
		var data = GetDataAsync().Result;
		
		return View(data);  
	}

Здесь вы получите взаимную блокировку. Почему? Потому что геттер свойства Result будет блокировать поток до тех пор, пока операция async не будет завершена, но поскольку метод async будет автоматически возвращать результат на оригинальный поток, а ASP.NET использует однопоточный контекст синхронизации, они будут продолжать ждать друг друга. Похожая проблема также может возникнуть с WPF, Silverlight или с C#/XAML приложениями Windows Store. Вы можете узнать об этом больше [здесь](http://blogs.msdn.com/b/pfxteam/archive/2011/01/13/10115163.aspx).
